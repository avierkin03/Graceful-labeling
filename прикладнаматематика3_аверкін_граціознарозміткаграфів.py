# -*- coding: utf-8 -*-
"""ПрикладнаМатематика3_Аверкін_ГраціознаРозміткаГрафів.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oN8GvQyDWDWjviMIv14pD7jHwGoEpBlN
"""

#------------------------ГРАЦІОЗНА РОЗМІТКА ГРАФІВ-ЛАНЦЮГІВ---------------------
import networkx as nx

#перевірка чи є граф ланцюгом
def is_pathgraph(G):
    degrees = dict(G.degree())
    ends = [v for v, d in degrees.items() if d == 1]
    if len(ends) != 2:
        return False
    for v, d in degrees.items():
        if d != 2 and v not in ends:
            return False
    return True

#Функція, що граціозно маркує граф-ланцюг
def pathgraph_labeling(G):
  if not is_pathgraph(G):
        print("Граф не є ланцюгом")
        return
  n = len(G)
  labels = {}
  for node in sorted(G.nodes()):
    if(node % 2 == 0):
      labels[node] = node//2
    else:
      labels[node] = n - (node+1)//2
  return labels

# Приклад використання
G = nx.Graph([(0, 1), (1, 2), (2, 3)])
labels = pathgraph_labeling(G)

print("Граціозна розмітка: ", labels)

#--------------------------ГРАЦІОЗНА РОЗМІТКА ПОВНИХ ГРАФІВ---------------------
import networkx as nx

# перевірка чи є граф повним (кількість ребер у графі має
# дорівнювати n(n-1)/2, де n - кількість вершин у графі)
def isComplete(graph):
  n = len(G.nodes())
  if len(G.edges()) == n*(n-1)/2:
    return True
  else:
    return False

#Функція, що граціозно маркує повний граф
def completeGraph_labeling(graph):
  n = len(G.nodes())
  m = len(G.edges())
  if isComplete(G) and n <= 4:
    n = len(graph)
    labeling = {}
    if n == 1:
        labeling[0] = 0
    elif n == 2:
        labeling[0] = 0
        labeling[1] = m
    elif n == 3:
        labeling[0] = 0
        labeling[1] = m
        labeling[2] = 1
    elif n == 4:
        labeling[0] = 0
        labeling[1] = m
        labeling[2] = 1
        labeling[3] = 4
    else:
        return None
    return labeling
  else:
    print("Граф не є повним або має більше 4 вершин.")

# Приклад використання
G = nx.Graph([(0, 1), (0, 2), (0, 3), (1,2), (1,3), (2,3)])
labeling = completeGraph_labeling(G)
print("Граціозна розмітка: ", labeling)

#-----------------ГРАЦІОЗНА РОЗМІТКА ПОВНИХ ДВОЧАСТКОВИХ ГРАФІВ-----------------
import networkx as nx

#Функція, що граціозно маркує повний двочастковий граф
def completeBipartiteGraph_labeling(m, n):
    graph = nx.complete_bipartite_graph(m, n)
    labeling = {}
    for i in range(m):
        labeling[i] = i
    for j in range(n):
        labeling[m+j] = (j+1)*m
    return labeling

# Приклад використання
m, n = 3, 4
labeling = completeBipartiteGraph_labeling(m, n)
print("Граціозна розмітка: ", labeling)

#------------------------------ГРАЦІОЗНА РОЗМІТКА ЦИКЛІВ------------------------
import networkx as nx

#перевірка чи є граф циклом
def is_cycle(G):
    if not nx.is_connected(G):
        return False
    for node in G.nodes:
        if G.degree(node) != 2:
            return False
    return True

#Функція, що граціозно маркує цикл
def cycle_labeling(G):
  if not is_cycle(G):
    print("Граф не є циклом")
    return
  n = G.number_of_nodes()
  labels = {}
  if(n % 4 == 0):
    for i in range(n):
      if i in range(n//2 + 1, n, 2):
        labels[i] = n - (i-1)//2 - 1
      elif (i % 2 == 0 and i < n-1):
        labels[i] = i // 2
      elif i in range(1, (n//2), 2):
        labels[i] = n - (i-1)//2
    return labels
  elif (n % 4 == 3):
    for i in range(n):
      if i in range((n+1)//2 + 1, n-1, 2):
        labels[i] = n - (i-1)//2 - 1
      elif(i % 2 == 0):
        labels[i] = i // 2
      elif i in range(1, ((n+1)//2), 2):
        labels[i] = n - (i-1)//2
    return labels
  else:
      return("Для даної к-ті вершин циклу неможливо задати граціозну розмітку")

# Приклад використання
C4 = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
labeling_C4 = cycle_labeling(C4)
print("Граціозна розмітка C4: ", labeling_C4)

C7 = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 0)])
labeling_C7 = cycle_labeling(C7)
print("Граціозна розмітка C7: ", labeling_C7)

#-----------------------------ГРАЦІОЗНА РОЗМІТКА КОЛЕС--------------------------
#Функція, що граціозно маркує колесо
def wheel_labeling(graph):
    p = len(graph) - 1
    labeling = {}
    if(p % 2 == 0):
      for i, vertex in enumerate(graph):
        if vertex == "v":
          labeling[vertex] = 0
        elif i == 0:
            labeling[vertex] = 2*p
        elif i == p-1:
            labeling[vertex] = 2
        elif i % 2 == 1:
            labeling[vertex] = i
        else:
            labeling[vertex] = 2*p - i - 1
    if(p % 2 == 1):
      for i, vertex in enumerate(graph):
        if vertex == "v":
          labeling[vertex] = 0
        elif i == 0:
          labeling[vertex] = 2*p
        elif i == 1:
          labeling[vertex] = 2
        elif i % 2 == 0:
          labeling[vertex] = p + i
        else:
          labeling[vertex] = p + 1 - i
    return labeling

# Приклад використання
W5 = ["u0", "u1", "u2", "u3", "u4", "v"]
labeling_W5 = wheel_labeling(W5)
print(labeling_W5)

W4 = ["u0", "u1", "u2", "u3", "v"]
labeling_W4 = wheel_labeling(W4)
print(labeling_W4)